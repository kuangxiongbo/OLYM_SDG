# 🚀 SDG Web界面部署指南

## 📋 概述

本指南详细介绍了如何在不同环境中部署SDG Web界面，包括开发环境、生产环境和云端部署。

## 🏠 本地开发部署

### 环境要求

- **Python**: 3.8+
- **操作系统**: Windows, macOS, Linux
- **内存**: 至少4GB RAM
- **存储**: 至少2GB可用空间

### 快速部署

```bash
# 1. 克隆项目
git clone <repository-url>
cd SDG项目文件/Web界面/

# 2. 创建虚拟环境
python3 -m venv venv
source venv/bin/activate  # Linux/macOS
# 或
venv\Scripts\activate     # Windows

# 3. 安装依赖
pip install -r requirements.txt

# 4. 配置环境变量
cp env_template .env
# 编辑.env文件，填入配置

# 5. 启动服务
python app.py
```

### 使用启动脚本

```bash
# 使用提供的启动脚本（推荐）
chmod +x start.sh
./start.sh
```

### 访问应用

打开浏览器访问: **http://localhost:5000**

## 🏭 生产环境部署

### 使用Gunicorn部署

```bash
# 1. 安装Gunicorn
pip install gunicorn

# 2. 创建Gunicorn配置文件
cat > gunicorn.conf.py << EOF
bind = "0.0.0.0:5000"
workers = 4
worker_class = "sync"
worker_connections = 1000
timeout = 30
keepalive = 2
max_requests = 1000
max_requests_jitter = 100
preload_app = True
EOF

# 3. 启动Gunicorn
gunicorn -c gunicorn.conf.py app:app
```

### 使用uWSGI部署

```bash
# 1. 安装uWSGI
pip install uwsgi

# 2. 创建uWSGI配置文件
cat > uwsgi.ini << EOF
[uwsgi]
module = app:app
master = true
processes = 4
socket = /tmp/uwsgi.sock
chmod-socket = 666
vacuum = true
die-on-term = true
EOF

# 3. 启动uWSGI
uwsgi --ini uwsgi.ini
```

### Nginx反向代理配置

```nginx
server {
    listen 80;
    server_name your-domain.com;

    location / {
        proxy_pass http://127.0.0.1:5000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location /static {
        alias /path/to/Web界面/static;
        expires 30d;
    }

    client_max_body_size 50M;
}
```

## ☁️ 云端部署

### Docker部署

#### 1. 创建Dockerfile

```dockerfile
FROM python:3.9-slim

WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    && rm -rf /var/lib/apt/lists/*

# 复制依赖文件
COPY requirements.txt .

# 安装Python依赖
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY . .

# 创建必要目录
RUN mkdir -p uploads results

# 暴露端口
EXPOSE 5000

# 启动命令
CMD ["gunicorn", "-c", "gunicorn.conf.py", "app:app"]
```

#### 2. 创建docker-compose.yml

```yaml
version: '3.8'

services:
  web:
    build: .
    ports:
      - "5000:5000"
    environment:
      - FLASK_ENV=production
      - FLASK_DEBUG=False
    volumes:
      - ./uploads:/app/uploads
      - ./results:/app/results
    restart: unless-stopped

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./static:/app/static
    depends_on:
      - web
    restart: unless-stopped
```

#### 3. 部署命令

```bash
# 构建和启动
docker-compose up -d

# 查看日志
docker-compose logs -f

# 停止服务
docker-compose down
```

### AWS部署

#### 使用Elastic Beanstalk

```bash
# 1. 安装EB CLI
pip install awsebcli

# 2. 初始化EB应用
eb init

# 3. 创建环境
eb create production

# 4. 部署应用
eb deploy
```

#### 使用ECS

```yaml
# task-definition.json
{
  "family": "sdg-web",
  "networkMode": "awsvpc",
  "requiresCompatibilities": ["FARGATE"],
  "cpu": "512",
  "memory": "1024",
  "executionRoleArn": "arn:aws:iam::account:role/ecsTaskExecutionRole",
  "containerDefinitions": [
    {
      "name": "sdg-web",
      "image": "your-account.dkr.ecr.region.amazonaws.com/sdg-web:latest",
      "portMappings": [
        {
          "containerPort": 5000,
          "protocol": "tcp"
        }
      ],
      "environment": [
        {
          "name": "FLASK_ENV",
          "value": "production"
        }
      ],
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "/ecs/sdg-web",
          "awslogs-region": "us-west-2",
          "awslogs-stream-prefix": "ecs"
        }
      }
    }
  ]
}
```

### Google Cloud部署

#### 使用Cloud Run

```bash
# 1. 构建镜像
gcloud builds submit --tag gcr.io/PROJECT-ID/sdg-web

# 2. 部署到Cloud Run
gcloud run deploy sdg-web \
  --image gcr.io/PROJECT-ID/sdg-web \
  --platform managed \
  --region us-central1 \
  --allow-unauthenticated
```

### Azure部署

#### 使用Container Instances

```bash
# 1. 创建资源组
az group create --name sdg-rg --location eastus

# 2. 创建容器实例
az container create \
  --resource-group sdg-rg \
  --name sdg-web \
  --image your-registry/sdg-web:latest \
  --dns-name-label sdg-web \
  --ports 5000
```

## 🔧 配置管理

### 环境变量配置

```bash
# 生产环境配置
export FLASK_ENV=production
export FLASK_DEBUG=False
export SECRET_KEY=your-secret-key-here
export MAX_CONTENT_LENGTH=52428800
export UPLOAD_FOLDER=/app/uploads
export RESULTS_FOLDER=/app/results

# 数据库配置（如果使用）
export DATABASE_URL=postgresql://user:password@localhost/sdg_db

# API配置
export OPENAI_API_KEY=your-openai-key
export OPENAI_API_URL=https://api.openai.com/v1/
export DEEPSEEK_API_KEY=your-deepseek-key
export DEEPSEEK_API_URL=http://localhost:8000/v1/

# 日志配置
export LOG_LEVEL=INFO
export LOG_FILE=/app/logs/app.log
```

### 配置文件管理

```python
# config.py
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'dev-secret-key'
    DEBUG = os.environ.get('FLASK_DEBUG', 'False').lower() == 'true'
    MAX_CONTENT_LENGTH = int(os.environ.get('MAX_CONTENT_LENGTH', 50 * 1024 * 1024))
    
class ProductionConfig(Config):
    DEBUG = False
    SECRET_KEY = os.environ.get('SECRET_KEY')
    
class DevelopmentConfig(Config):
    DEBUG = True
```

## 📊 监控和日志

### 日志配置

```python
import logging
from logging.handlers import RotatingFileHandler

if not app.debug:
    file_handler = RotatingFileHandler('logs/app.log', maxBytes=10240, backupCount=10)
    file_handler.setFormatter(logging.Formatter(
        '%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'
    ))
    file_handler.setLevel(logging.INFO)
    app.logger.addHandler(file_handler)
    app.logger.setLevel(logging.INFO)
    app.logger.info('SDG Web界面启动')
```

### 健康检查

```python
@app.route('/health')
def health_check():
    return jsonify({
        'status': 'healthy',
        'timestamp': datetime.now().isoformat(),
        'version': '1.0.0'
    })
```

### 性能监控

```python
from flask import request
import time

@app.before_request
def before_request():
    request.start_time = time.time()

@app.after_request
def after_request(response):
    if hasattr(request, 'start_time'):
        duration = time.time() - request.start_time
        app.logger.info(f'{request.method} {request.path} - {response.status_code} - {duration:.3f}s')
    return response
```

## 🔒 安全配置

### HTTPS配置

```python
# 使用Flask-TLS
from flask_tls import TLS

app = Flask(__name__)
tls = TLS(app)

# 或使用Nginx SSL终止
```

### 安全头配置

```python
from flask_talisman import Talisman

Talisman(app, force_https=True)
```

### 访问控制

```python
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

limiter = Limiter(
    app,
    key_func=get_remote_address,
    default_limits=["200 per day", "50 per hour"]
)

@app.route('/api/v1/synthesis/generate')
@limiter.limit("10 per minute")
def generate_synthetic_data():
    # API限制
    pass
```

## 📈 性能优化

### 缓存配置

```python
from flask_caching import Cache

cache = Cache(app, config={'CACHE_TYPE': 'redis'})

@app.route('/api/v1/models')
@cache.cached(timeout=300)
def get_available_models():
    # 缓存5分钟
    pass
```

### 数据库优化

```python
# 使用连接池
from sqlalchemy import create_engine
from sqlalchemy.pool import QueuePool

engine = create_engine(
    DATABASE_URL,
    poolclass=QueuePool,
    pool_size=10,
    max_overflow=20,
    pool_pre_ping=True
)
```

### 静态文件优化

```python
from flask_compress import Compress

Compress(app)
```

## 🚨 故障排除

### 常见问题

#### 1. 端口被占用
```bash
# 查找占用端口的进程
lsof -i :5000
# 或
netstat -tulpn | grep :5000

# 杀死进程
kill -9 PID
```

#### 2. 内存不足
```bash
# 检查内存使用
free -h
# 或
top -o %MEM
```

#### 3. 磁盘空间不足
```bash
# 检查磁盘使用
df -h
# 清理日志文件
find /app/logs -name "*.log" -mtime +7 -delete
```

#### 4. 依赖安装失败
```bash
# 更新pip
pip install --upgrade pip

# 使用国内镜像
pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple/
```

### 日志分析

```bash
# 查看错误日志
grep "ERROR" /app/logs/app.log

# 查看访问日志
tail -f /var/log/nginx/access.log

# 分析性能
grep "duration" /app/logs/app.log | awk '{print $NF}' | sort -n
```

## 🔄 更新和维护

### 应用更新

```bash
# 1. 备份当前版本
cp -r /app /app.backup.$(date +%Y%m%d)

# 2. 拉取新代码
git pull origin main

# 3. 更新依赖
pip install -r requirements.txt

# 4. 重启服务
systemctl restart sdg-web
```

### 数据备份

```bash
# 备份上传文件
tar -czf uploads_backup_$(date +%Y%m%d).tar.gz uploads/

# 备份结果文件
tar -czf results_backup_$(date +%Y%m%d).tar.gz results/

# 备份数据库（如果使用）
pg_dump sdg_db > sdg_db_backup_$(date +%Y%m%d).sql
```

### 监控脚本

```bash
#!/bin/bash
# health_check.sh

URL="http://localhost:5000/health"
RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" $URL)

if [ $RESPONSE -eq 200 ]; then
    echo "服务正常"
else
    echo "服务异常，状态码: $RESPONSE"
    # 发送告警
    systemctl restart sdg-web
fi
```

## 📞 技术支持

### 获取帮助

1. **查看日志**: 检查应用日志和系统日志
2. **检查配置**: 验证环境变量和配置文件
3. **测试连接**: 使用健康检查接口
4. **社区支持**: 在GitHub Issues提问
5. **邮件支持**: 发送邮件到技术支持

### 联系方式

- **GitHub**: https://github.com/your-repo/sdg-web
- **邮箱**: support@example.com
- **文档**: https://docs.example.com

---

**版本**: 1.0.0  
**最后更新**: 2025-09-18  
**维护者**: SDG开发团队
